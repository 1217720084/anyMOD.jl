var documenterSearchIndex = {"docs":
[{"location":"quick_start/#Quick-Start-1","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"The example project \"precompile\" is used to introduce the packages’ top-level functions. After adding anyMOD to your project, the function anyModel constructs an anyMOD model object by reading in the csv files found within the directory specified by the first argument. The second argument specifies a directory all model outputs are written to. Furthermore, default model options can be replaced via optional arguments.","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"using anyMOD\r\nanyM = anyModel(\"examples/precompile\",\"output\")","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"addVariables! and addConstraints! determine, which optimization variables and constraints the specific model requires and adds them.","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"addVariables!(anyM)\r\naddConstraints!(anyM)","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"Afterwards, setObjective! sets the objective function of the optimization problem. The first argument serves as a key for the respective objective. To enable multi-objective optimization, instead of a single symbol this could also be a dictionary that assigns a respective keyword to its weight in the final objective function. So far only costs have been implemented as an objective.","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"setObjective!(:costs,anyM)","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"Finally, the JuMP model object of is be passed to a solver. Afterwards, the value of optimization variables can be printed to csv files via the printObject command.","category":"page"},{"location":"quick_start/#","page":"Quick start","title":"Quick start","text":"using Gurobi\r\nJuMP.optimize!(anyM.optModel,with_optimizer(Gurobi.Optimizer, OutputFlag=1))\r\nprintObject(anyM.sets.variables[:capaConv],anyM.sets , anyM.options)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"anyMOD is a Julia framework to set up large scale linear energy system models with a focus on multi-period capacity expansion. It was developed to address the challenges in modelling high-levels of intermittent generation and sectoral integration.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The framework's key characteristic is, that all sets (time-steps, regions, energy carriers, and technlogies) are each organized within a hierarchical tree structure. This allows for several unique features:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The spatial and temporal resolution at which generation, use and transport of energy is modelled can be varied by energy carrier. For example, within the same model electricity can be modelled at an hourly, but gas at a daily resolution, while still allowing for technologies that convert gas to electricity, or vice versa. As a result, a substantial decrease of computational effort can be achieved.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The substitution of energy carriers with regard to conversion, consumption and transport can be modelled. As an example, residential and district heat can both equally satisfy heat demand, but technologies to produce these carriers and how they are restricted are different.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Inheritance within the trees can be exploited to dynamically obtain the model's parameters from the input data provided. In case of a technology’s efficiency for instance, parameters can vary by hour, day or be irrespective of time, depending on weather input data was provided hourly, daily or without any temporal dimension specified.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The tool relies on the JuMP package to create optimization problems and uses JuliaDB to store and process their elements. The programs current preliminary stage has not been extensively tested yet. With the release of Julia 1.3, a utilization of multi-threading to speed-up model generation and an interface with packages for distributed decomposition methods for linear problems is planned.","category":"page"}]
}
